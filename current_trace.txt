/Users/tillife/Documents/CodingProjects/nabla/nabla/core/tensor.py:456: UserWarning: Use of synchronous tensor method inside another event loop.
  warnings.warn("Use of synchronous tensor method inside another event loop.")
WARNING: accelerator_count() returns 0 on Apple devices. While Mojo now supports Apple GPUs, that support has not been enabled in MAX and Python APIs yet
WARNING: accelerator_count() returns 0 on Apple devices. While Mojo now supports Apple GPUs, that support has not been enabled in MAX and Python APIs yet
/opt/homebrew/Cellar/python@3.13/3.13.6/Frameworks/Python.framework/Versions/3.13/lib/python3.13/asyncio/base_events.py:764: ResourceWarning: unclosed event loop <_UnixSelectorEventLoop running=False closed=False debug=False>
  _warn(f"unclosed event loop {self!r}", ResourceWarning, source=self)
ResourceWarning: Enable tracemalloc to get the object allocation traceback
.
----------------------------------------------------------------------
Ran 1 test in 1.186s

OK

================================================================================
TRANSFORMER PP (2D PATTERN)
================================================================================

Shapes:
  x: [Dim(4), Dim(32)] <*, stage> local [Dim(4), Dim(8)]
  Wq: [Dim(32), Dim(8)] <stage, *> local [Dim(8), Dim(8)]

ðŸ“Š TRACE:
------------------------------------------------------------
DEBUG: Contracting {'k'}, Preserved set()
DEBUG: Contracting {'k'}, Preserved set()
DEBUG: Contracting {'k'}, Preserved set()
DEBUG: Contracting {'k'}, Preserved {'stage'}
[1mfn[0m(
    [96m%a1[0m: f32[4,32](<*, stage>)(local=[4,8]),
    [96m%a2[0m: f32[32,8](<stage, *>)(local=[8,8]),
    [96m%a3[0m: f32[32,8](<stage, *>)(local=[8,8]),
    [96m%a4[0m: f32[32,8](<stage, *>)(local=[8,8]),
    [96m%a5[0m: f32[8,32](<*, stage>)(local=[8,8])
) @pp(shape=(4,), devices=[0,1,2,3], axes=(stage)) {
  [1mspmd[0m @pp(shape=(4,), devices=[0,1,2,3], axes=(stage)) {
    [96m%v1[0m: f32[4,8](<*, *>)(local=[4,8]) = matmul([96m%a1[0m, [96m%a2[0m)
  }
  [96m%v2[0m: f32[4,8](<*, *>)(local=[4,8]) = all_reduce([96m%v1[0m, mesh=@pp, reduce_axes=('stage',))
  [1mspmd[0m @pp(shape=(4,), devices=[0,1,2,3], axes=(stage)) {
    [96m%v3[0m: f32[4,8](<*, *>)(local=[4,8]) = matmul([96m%a1[0m, [96m%a3[0m)
  }
  [96m%v4[0m: f32[4,8](<*, *>)(local=[4,8]) = all_reduce([96m%v3[0m, mesh=@pp, reduce_axes=('stage',))
  [1mspmd[0m @pp(shape=(4,), devices=[0,1,2,3], axes=(stage)) {
    [96m%v5[0m: f32[8,4](<*, *>)(local=[8,4]) = swap_axes([96m%v4[0m, axis1=0, axis2=1)
    [96m%v6[0m: f32[4,4](<*, *>)(local=[4,4]) = matmul([96m%v2[0m, [96m%v5[0m)
    [96m%v7[0m: f32[4,4](<*, *>)(local=[4,4]) = softmax([96m%v6[0m, axis=-1)
    [96m%v8[0m: f32[4,8](<*, *>)(local=[4,8]) = matmul([96m%a1[0m, [96m%a4[0m)
  }
  [96m%v9[0m: f32[4,8](<*, *>)(local=[4,8]) = all_reduce([96m%v8[0m, mesh=@pp, reduce_axes=('stage',))
  [1mspmd[0m @pp(shape=(4,), devices=[0,1,2,3], axes=(stage)) {
    [96m%v10[0m: f32[4,8](<*, *>)(local=[4,8]) = matmul([96m%v7[0m, [96m%v9[0m)
    [96m%v11[0m: f32[4,32](<*, stage>)(local=[4,8]) = matmul([96m%v10[0m, [96m%a5[0m)
    [96m%v12[0m: f32[4,32](<*, stage>)(local=[4,8]) = add([96m%a1[0m, [96m%v11[0m)
  }
  [96m%v13[0m: f32[4,32](<*, stage>)(local=[4,8]) = ppermute([96m%v12[0m, permutation=((0,1),(1,2),(2,3),(3,0)))
  [1mreturn[0m [96m%v13[0m
}
------------------------------------------------------------
DEBUG: Contracting {'k'}, Preserved set()
DEBUG: Contracting {'k'}, Preserved set()
DEBUG: Contracting {'k'}, Preserved set()
DEBUG: Contracting {'k'}, Preserved {'stage'}

âœ… PASS: Result shape [Dim(4), Dim(32)]
âœ… PASS: Numerical verification
